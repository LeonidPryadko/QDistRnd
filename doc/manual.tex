% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}
 
                        \newcommand{\rank}{\mathop{\rm rank}}
                        \newcommand{\wgt}{\mathop{\rm wgt}} 
                        %\parindent=0pt                
                        %\parskip\bigskipamount
                        
\usepackage[top=37mm,bottom=37mm,left=27mm,right=27mm]{geometry}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ QDistRnd \mbox{}}}\\
\vfill

\hypersetup{pdftitle= QDistRnd }
\markright{\scriptsize \mbox{}\hfill  QDistRnd  \hfill\mbox{}}
{\Huge \textbf{ Calculate the distance of a q-ary quantum stabilizer code \mbox{}}}\\
\vfill

{\Huge  0.3.0 \mbox{}}\\[1cm]
{ 30 July 2021 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Leonid P. Pryadko\\
    \mbox{}}}\\
{\Large \textbf{ Vadim A. Shabashov\\
    \mbox{}}}\\
\hypersetup{pdfauthor= Leonid P. Pryadko\\
    ;  Vadim A. Shabashov\\
    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Leonid P. Pryadko\\
    }  Email: \href{mailto://leonid.pryadko@gmail.com} {\texttt{leonid.pryadko@gmail.com}}\\
  Homepage: \href{http://faculty.ucr.edu/~leonid} {\texttt{http://faculty.ucr.edu/\texttt{\symbol{126}}leonid}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Leonid Pryadko\\
 Department of Physics \& Astronomy\\
 University of California\\
 Riverside, CA 92521\\
 USA\\
 \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Vadim A. Shabashov\\
    }  Email: \href{mailto://vadim.art.shabashov@gmail.com} {\texttt{vadim.art.shabashov@gmail.com}}\\
  Homepage: \href{https://sites.google.com/view/vadim-shabashov/} {\texttt{https://sites.google.com/view/vadim-shabashov/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Vadim Shabashov\\
 The Department of Physics \& Engineering\\
 ITMO University\\
 St. Petersburg, 197101\\
 Russia\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 \index{License} {\copyright} 2021 by Leonid P. Pryadko and Vadim A. Shabashov

 \textsf{QDistRnd} package is free software; you can redistribute it and/or modify it under the
terms of the \href{http://www.fsf.org/licenses/gpl.html} {GNU General Public License} as published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 2 ]}
 We appreciate very much all past and future comments, suggestions and
contributions to this package and its documentation provided by \textsf{GAP} users and developers. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

     
\chapter{\textcolor{Chapter }{Introduction}}\label{Chapter_Introduction}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  

 The \textsf{GAP} package \textsf{QDistRnd} gives a reference implementation of a probabilistic algorithm for finding the
distance of a $q$-ary quantum low-density parity-check code linear over a finite field $F=GF(q)$. While there is no guarantee of the performance of the algorithm (the
existing bounds in the case of quantum LDPC codes are weak, see \ref{Subsection_TheAlgorithmDetails}), an empirical convergence criterion is given to estimate the probability
that a minimum weight codeword has been found. Versions for CSS and regular
stabilizer codes are given, see Section \ref{Section_DistanceFunctions} 

 In addition, a format for storing matrices associated with $q$-ary quantum codes is introduced and implemented, see Chapter \ref{Chapter_FileFormat} and Sec. \ref{Section_IOFunctions}. The format is based on the well establised MaTrix market eXchange (MTX)
Coordinate format developed at NIST, and is designed for full backward
compatibility with this format. Thus, the files are readable by any software
package which supports MTX. 

 The routines in the package are derived from the code originally written by
one of the authors (LPP). A related Covering Set algorithm has a provable
performance for generic (non-LDPC) quantum codes based on random matrices \cite{Dumer-Kovalev-Pryadko-IEEE-2017}. Implemented version is a variant of the random \emph{information set} (IS) algorithm based on random column permutations and Gauss' elimination \cite{Leon-1988} \cite{Kruk-1989} \cite{Coffey-Goodman-1990}. 

 The \textsf{GAP} computer algebra system was chosen because of its excellent support for linear
algebra over finite fields. Here we give a reference implementation of the
algorithm, with a focus on matrix formats and generality, as opposed to
performance. Nevertheless, the routines are sufficiently fast when dealing
with codes of practically important block lengths $n\lesssim 10^3$. 

 }

   
\chapter{\textcolor{Chapter }{Examples}}\label{Chapter_Examples}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
  

 A few simple examples illustrating the use of the package. For more
information see Chapter \ref{Chapter_AllFunctions} 

 
\section{\textcolor{Chapter }{The 5-qubit code}}\label{Chapter_Examples_Section_The_5-qubit_code}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7B229D2B7E58ED2E}{}
{
  Generate the matrix of the 5-qubit code over GF(3) with the stabilizer group
generated by cyclic shifts of the operator $X_0Z_1 \bar Z_2 \bar X_3$ which corresponds to the polynomial $h(x)=1+x^3-x^5-x^6$ (a factor $X_i^a$ corresponds to a monomial $a x^{2i}$, and a factor $Z_i^b$ to a monomial $b x^{2i+1}$), calculate the distance, and save into the file. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@q:=3;; F:=GF(q);; |
  !gapprompt@gap>| !gapinput@x:=Indeterminate(F,"x");; poly:=One(F)*(1+x^3-x^5-x^6);;|
  !gapprompt@gap>| !gapinput@n:=5;;|
  !gapprompt@gap>| !gapinput@mat:=QDR_DoCirc(poly,n-1,2*n,F);; #construct circulant matrix with 4 rows |
  !gapprompt@gap>| !gapinput@Display(mat);|
   1 . . 1 . 2 2 . . .
   . . 1 . . 1 . 2 2 .
   2 . . . 1 . . 1 . 2
   . 2 2 . . . 1 . . 1
  !gapprompt@gap>| !gapinput@d:=DistRandStab(mat,100,1,0 : field:=F,maxav:=20/n);|
  3
  !gapprompt@gap>| !gapinput@WriteMTXE("tmp/n5_q3_complex.mtx",3,mat,|
  !gapprompt@>| !gapinput@        "% The 5-qubit code [[5,1,3]]_3",|
  !gapprompt@>| !gapinput@        "% Generated from h(x)=1+x^3-x^5-x^6",|
  !gapprompt@>| !gapinput@        "% Example from the QDistRnd GAP package"   : field:=F);|
  File tmp/n5_q3_complex.mtx was created
\end{Verbatim}
 Here is the contents of the resulting file which also illustrates the \texttt{complex} data format. Here a pair $(a_{i,j},b_{i,j})$ in row $i$ and column $j$ is written as 4 integers, "$i$ $j$ $a_{i,j}$ $b_{i,j}$", e.g., "1 2 0 1" for the second entry in the 1st row, so that the matrix in
the file has $n$ columns. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  %%MatrixMarket matrix coordinate complex general
  % Field: GF(3)
  % The 5-qubit code [[5,1,3]]_3
  % Generated from h(x)=1+x^3-x^5-x^6
  % Example from the QDistRnd GAP package
  % Values Z(3) are given
  4 5 20
  1 1 1 0
  1 2 0 1
  1 3 0 2
  1 4 2 0
  2 2 1 0
  2 3 0 1
  2 4 0 2
  2 5 2 0
  3 1 2 0
  3 3 1 0
  3 4 0 1
  3 5 0 2
  4 1 0 2
  4 2 2 0
  4 4 1 0
  4 5 0 1
\end{Verbatim}
 And now let us read the matrix back the file. In the simplest case, all
optional parameters are read from the file. Output is a list: \texttt{[field,mode,matrix,(list of comments)]}. Notice that a \texttt{mode=2} or \texttt{mode=3} matrix is always converted to \texttt{mode=1}, i.e., with $2n$ intercalated columns $(a_1,b_1,a_2,b_2,\ldots)$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lis:=ReadMTXE("tmp/n5_q3_complex.mtx");;  |
  !gapprompt@gap>| !gapinput@lis[1]; # the field |
  GF(3)
  !gapprompt@gap>| !gapinput@lis[2]; # converted to `mode=1`|
  1
  !gapprompt@gap>| !gapinput@Display(lis[3]);|
   1 . . 1 . 2 2 . . .
   . . 1 . . 1 . 2 2 .
   2 . . . 1 . . 1 . 2
   . 2 2 . . . 1 . . 1
\end{Verbatim}
 The remaining portion is the list of comments. Notice that the 1st and the
last coment lines have been added automatically. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lis[4];|
  [ "% Field: GF(3)", "% The 5-qubit code [[5,1,3]]_3",
    "% Generated from h(x)=1+x^3-x^5-x^6",
    "% Example from the QDistRnd GAP package", "% Values Z(3) are given" ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Hyperbolic codes from a file}}\label{Chapter_Examples_Section_Hyperbolic_codes_from_a_file}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X87244D1D7FAA03A1}{}
{
  Here we read a pair of matrices from two different files which correspond to a
hyperbolic code $[[80,18,5]]$ with row weight $w=5$ and the asymptotic rate $1/5$. Notice that \texttt{pair=0} is used for both files (regular matrices). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lisX:=ReadMTXE("matrices/QX80.mtx",0);;|
  !gapprompt@gap>| !gapinput@GX:=lisX[3];;|
  !gapprompt@gap>| !gapinput@lisZ:=ReadMTXE("matrices/QZ80.mtx",0);;|
  !gapprompt@gap>| !gapinput@GZ:=lisZ[3];;|
  !gapprompt@gap>| !gapinput@DistRandCSS(GX,GZ,100,1,2:field:=GF(2));|
  5
\end{Verbatim}
 Here are the matrices for a much bigger hyperbolic code $[[900,182,8]]$ from the same family. Note that the distance here scales only logarithmically
with the code length (this code takes about 15 seconds on a typical notebook
and will not actually be executed). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lisX:=ReadMTXE("matrices/QX900.mtx",0);;|
  !gapprompt@gap>| !gapinput@GX:=lisX[3];;|
  !gapprompt@gap>| !gapinput@lisZ:=ReadMTXE("matrices/QZ900.mtx",0);;|
  !gapprompt@gap>| !gapinput@GZ:=lisZ[3];;|
  !gapprompt@gap>| !gapinput@DistRandCSS(GX,GZ,1000,1,0:field:=GF(2));|
  8
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Randomly generated cyclic codes}}\label{Chapter_Examples_Section_Randomly_generated_cyclic_codes}
\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X7A1DF21D8626DA84}{}
{
  

 As a final and hopefully somewhat useful example, the file "lib/cyclic.g"
contains a piece of code searching for random one-generator cyclic codes of
length $n=15$ over the field $GF(5)$, and generator weight \texttt{wei=4}. Note how the \texttt{mindist} parameter and the option \texttt{maxav} are used to speed up the calculation. }

 

 }

   
\chapter{\textcolor{Chapter }{Description of the algorithm}}\label{Chapter_Description}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7E421FAB7D974939}{}
{
  

 
\section{\textcolor{Chapter }{Elementary version}}\label{Section_SimpleVersion}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7DDF42DF7D7F87EF}{}
{
  

 
\subsection{\textcolor{Chapter }{What it does?}}\label{Subsection_TheGoal}
\logpage{[ 3, 1, 1 ]}
\hyperdef{L}{X7AE39C5583A02936}{}
{
  

 In the simplest possible terms, we are given a pair of matrices $P$ and $Q$ with orthogonal rows, $PQ^T=0$. The matrices have entries in a finite field $F=GF(q)$, where $q$ is a power of a prime. The goal is to find the smallest weight of a vector $c$ over the same field $F$, such that $c$ be orthogonal with the rows of $P$, $Pc^T=0$, and linearly independent from the rows of $Q$. 

 }

 
\subsection{\textcolor{Chapter }{The algorithm}}\label{Subsection_TheProcedure}
\logpage{[ 3, 1, 2 ]}
\hyperdef{L}{X7C198D417DA58DFD}{}
{
  

 We first construct a generator matrix $G$ whose rows form a basis of the $F$-linear space of all vectors orthogonal to the rows of $P$. At each step, a random permutation $S$ is generated and applied to the columns of $G$. Then, Gauss' elimination with back substitution renders the resulting matrix
to the reduced row echelon form, after which the inverse permutation $S^{-1}$ is applied to the columns. Rows of the resulting matrix $G_S$ that are linearly independent from the rows of $Q$ are considered as candidates for the minimum weight vectors. Thus, after $N$ steps, we are getting an upper bound on the distance which is improving with
increasing $N$. 

 }

 
\subsection{\textcolor{Chapter }{Intuition}}\label{Subsection_Intuition}
\logpage{[ 3, 1, 3 ]}
\hyperdef{L}{X7C37FBD078DDC0D5}{}
{
  

 The intuition is that each row of $G_S$ is guaranteed to contain at least \texttt{rank}$(G_S)-1$ zeros. Thus, we are sampling mostly lower-weight vectors from the linear space
orthogonal to the rows of $P$. 

 }

 
\subsection{\textcolor{Chapter }{CSS version of the algorithm}}\label{Subsection_DistRandCSS}
\logpage{[ 3, 1, 4 ]}
\hyperdef{L}{X7A291E1E7CD313AB}{}
{
  

 The described version of the algorithm is implemented in the function \texttt{DistRandCSS} \ref{DistRandCSS}. It applies to the case of Calderbank-Shor-Steane (CSS) codes, where the
matrices $P=H_X$ and $Q=H_Z$ are called the CSS generator matrices, and the computed minimum weight is the
distance $d_Z$ of the code. The number of columns $n$ is the block length of the code, and it encodes $k$ qudits, where $k=n-$\texttt{rank}$(H_X)-$\texttt{rank}$(H_Z)$. To completely characterize the code, we also need the distance $d_X$ which can be obtained by calling the same function with the two matrices
interchanged. The conventional code distance $d$ is the minimum of $d_X$ and $d_Z$. Parameters of such a $q$-ary CSS code are commonly denoted as $[[n,k,(d_X,d_Z)]]_q$, or simply $[[n,k,d]]_q$ as for a general $q$-ary stabilizer code. 

 }

 
\subsection{\textcolor{Chapter }{Generic version of the algorithm}}\label{Subsection_DistRandStab}
\logpage{[ 3, 1, 5 ]}
\hyperdef{L}{X7D97C75283D26EE5}{}
{
  

 CSS codes are a subclass of general $F$-linear stabilizer codes which are specified by a single stabilizer generator
matrix $H=(A|B)$ written in terms of two blocks of $n$ columns each. The orthogonality condition is given in a symplectic form, 
\[ A B^T-B A^T=0, \]
 or, equivalently, as orthogonality between the rows of $H$ and the symplectic-dual matrix $\tilde H=(B|-A)$. Non-trivial vectors in the code must be orthogonal to the rows of $P=\tilde H$ and linearly independent from the rows of $Q=H$. The difference with the CSS version of the algorithm is that we must
minimize the \emph{symplectic} weight of $c=(a|b)$, given by the number of positions $i$, $1\le i\le n$, such that either $a_i$ or $b_i$ (or both) be non-zero. 

 The parameters of such a code are denoted as $[[n,k,d]]_q$, where $k=n-$\texttt{rank}$H$ is the number of encoded qudits, and $d$ is the minimal symplectic weight of a non-trivial vector in the code. It is
easy to check that a CSS code can also be represented in terms of a single
stabilizer generator matrix. Namely, for a CSS code with generators $H_X$ and $H_Z$, the stabilizer generator matrix has a block-diagonal form, $H=$\texttt{diag}$(H_X,H_Z)$. 

 A version of the algorithm for general $F$-linear stabilizer codes is implemented in the function \texttt{DistRandStab} \ref{DistRandStab}. 

 \emph{Important Notice}: In general, here one could use most general permutations of $2n$ columns, or restricted permutations of $n$ two-column blocks preserving the pair structure of the matrix. While the
latter method would be much faster, there is no guarantee that every vector
would be found. As a result, we decided to use general permutations of $2n$ columns. 

 }

 }

 
\section{\textcolor{Chapter }{Some more details}}\label{Chapter_Description_Section_Some_more_details}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7DA7BD6F7A61E553}{}
{
  
\subsection{\textcolor{Chapter }{Quantum stabilizer codes}}\label{Chapter_Description_Section_Some_more_details_Subsection_Quantum_stabilizer_codes}
\logpage{[ 3, 2, 1 ]}
\hyperdef{L}{X78810FD98017EB84}{}
{
  

 Representation of quantum codes in terms of linear spaces is just a convenient
map. In the case $q=2$ (qubits), the details can be found, e.g., in the book of Nielsen and Chuang, \cite{Nielsen-book}. Further details on the theory of stabilizer quantum error correcting codes
based on qubits can be found in the Caltech Ph.D. thesis of Daniel Gottesman \cite{gottesman-thesis} and in the definitive 1997 paper by Calderbank, Rains, Shor, and Sloane \cite{Calderbank-1997}. Theory of stabilizer quantum codes based on qudits ($q$-state quantum systems) was developed by Ashikhmin and Knill \cite{Ashikhmin-Knill-2001} (prime fields with $q$ prime) and by Ketkar, Klappenecker, Kumar, \& Sarvepalli \cite{Ketkar-Klappenecker-Kumar-Sarvepalli-2006} (extension fields with $q$ a non-trivial power of a prime). 

 In the binary case (more generally, when $q$ is a prime), $F$-linear codes coincide with \emph{additive} codes. The \emph{linear} codes [e.g., over $GF(4)$ in the binary case \cite{Calderbank-1997}] is a different construction which assumes an additional symmetry. A brief
summary of $F$-linear quantum codes [where $F=GF(q)$ with $q=p^m$, $m>1$ a non-trivial power of a prime] can be found in the introduction of Ref. \cite{Zeng-Pryadko-hprod-2020}. The construction is equivalent to a more physical approach in terms of a
lifted Pauli group suggested by Gottesman \cite{Gottesman-prime-power-2014}. 

 }

 
\subsection{\textcolor{Chapter }{The algorithm}}\label{Subsection_TheAlgorithmDetails}
\logpage{[ 3, 2, 2 ]}
\hyperdef{L}{X7C198D417DA58DFD}{}
{
  

 
\noindent\underline{%
 Case of \emph{classical linear codes} 
}
 

 The algorithm \ref{Subsection_TheProcedure} is closely related to the algorithm for finding minimum-weight codewords in a
classical linear code as presented by Leon \cite{Leon-1988}, and a related family of \emph{information set} (IS) decoding algorithms \cite{Kruk-1989} \cite{Coffey-Goodman-1990}. 

 Consider a classical linear $q$-ary code $[n,k,d]_q$ encoding $k$ symbols into $n$, specified by a generator matrix $G$ of rank $k$. Using Gauss' algorithm and column permutations, the generator matrix can be
rendered into a \emph{systematic form}, $G=(I|A)$, where the two blocks are $I$, the size-$k$ identity matrix, and a $k$ by $n-k$ matrix $A$. In such a representation, the first $k$ positions are called the information set of the code (since the corresponding
symbols are transmitted directly) and the remaining $n-k$ symbols provide the redundancy. Any $k$ linearly-independent columns of $G$ can be chosen as the information set, which defines the systematic form of $G$ up to a permutation of the rows of $A$. 

 The IS algorithm and the original performance bounds \cite{Leon-1988} \cite{Kruk-1989} \cite{Coffey-Goodman-1990} are based on the observation that for a long random code a set of $k+\Delta$ randomly selected columns, with $\Delta$ of order one, are likely to contain an information set. ISs are
(approximately) in one-to-one correspondence with the column permutations, and
a random IS can thus be generated as a set of \emph{pivot} columns in the Gauss' algorithm after a random column permutation. Thus, if
there is a codeword $c$ of weight $d$, the probability to find it among the rows of reduced-row-echelon form $G_S$ after a column permutation $S$ can be estimated as that for a randomly selected set of $k$ columns to hit exactly one non-zero position in $c$. 

 The statistics of ISs is more complicated in other ensembles of random codes,
e.g., in linear \emph{low-density parity-check} (LDPC) codes where the check matrix $H$ (of rank $n-k$ and with rows orthogonal to those of $G$) is additionally required to be sparse. Nevertheless, a provable bound can be
obtained for a related \emph{covering set} (CS) algorithm where a randomly selected set of $s\ge k-1$ positions of a putative codeword are set to be zero, and the remaining
positions are constructed with the help of linear algebra. In this case, the
optimal choice \cite{Dumer-Kovalev-Pryadko-IEEE-2017} is to take $s\approx n(1-\theta)$, where $\theta $ is the erasure threshold of the family of the codes under consideration. Since $\theta\ge R$ (here $R=k/n$ is the code rate), here more zeros must be selected, and the complexity would
grow (assuming the distance $d$ remains the same, which is usually \emph{not} the case for LDPC codes). 

 Note however that rows of $G_P$ other than the last are not expected to contain as many zeros (e.g., the first
row is only guaranteed to have $k-1$ zeros), so it is \emph{possible} that the performance of the IS algorithm on LDPC codes is actually closer to
that on random codes as estimated by Leon \cite{Leon-1988}. 

 
\medskip\noindent\underline{%
 Case of \emph{quantum CSS codes} 
}
 

 In the case of a random CSS code (with matrices $P$ and $Q$ selected randomly, with the only requirement being the orthogonality between
the rows of $P$ and $Q$), the performance of the algorithm \ref{Subsection_TheProcedure} can be estimated as that of the CS algorithm, in terms of the erasure
threshold of a linear code with the parity matrix $P$, see \cite{Dumer-Kovalev-Pryadko-IEEE-2017}. 

 Unfortunately, such an estimate fails dramatically in the case of \emph{quantum LDPC codes}, where rows of $P$ and $Q$ have weights bounded by some constant $w$. This is a reasonable requirement since the corresponding quantum operators
(supported on $w$ qudits) have to actually be measured frequently as a part of the operation of
the code, and it is reasonable to expect that the measurement accuracy goes
down (exponentially) quickly as $w$ is increased. Then, the linear code orthogonal to the rows of $P$ has the distance $\le w$ (the minimal weight of the rows of $Q$), and the corresponding erasure threshold is exactly zero. In other words,
there is a finite probability that a randomly selected $w$ symbols contain a vector orthogonal to the rows of $P$ (and such a vector would likely have nothing to do with non-trivial \emph{quantum} codewords which must be linearly independent from the rows of $Q$). 

 On the other hand, for every permutation $S$ in the algorithm \ref{Subsection_TheProcedure}, the matrix $G_S$ contains exactly $k=n-$\texttt{rank}$(P)-$\texttt{rank}$(Q)$ rows orthogonal to rows of $P$ and linearly independent from rows of $Q$ (with columns properly permuted). These vectors contain at least $s$ zeros, where $[1-\theta_*(P,Q)] n\le s\le n-$\texttt{rank}$(Q)$, where $\theta_*(P,Q)$ is the erasure threshold for $Z$-like codewords in the quantum CSS code with $H_X=P$ and $H_Z=Q$. 

 
\medskip\noindent\underline{%
 \emph{What is it that we do not understand?} 
}
 

 What missing is an understanding of the statistics of the ISs of interest,
namely, the ISs that overlap with a minimum-weight codeword in one (or a few)
positions. 

 Second, we know that a given column permutation $S$ leads to the unique information set, and that every information set can be
obtained by a suitably chosen column permutation. However, there is no
guarantee that the resulting information sets have equal probabilities. In
fact, it is easy to construct small matrices where different information sets
are obtained from different numbers of column permutations (and thus have
different probabilities). It is not clear whether some of the ISs may have
vanishingly small probabilities in the limit of large codes; in such a case
the algorithm would fail. 

 }

 }

 
\section{\textcolor{Chapter }{Empirical estimate of the success probability}}\label{Section_Empirical}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X7CCA4B9B834960EE}{}
{
  

 The probability to find a codeword after $N$ rounds of the algorithm can be estimated empirically, by counting the number
of times each codeword of the minimum weight was discovered. We \emph{expect} the probability $P(c)$ to discover a given codeword $c$ to depend only on its (symplectic) weight \texttt{wgt}$(c)$, with the probability a monotonously decreasing function of the weight. If,
after $N$ steps, codewords $c_1$, $c_2$, $\ldots$ , $c_m$ of the same (minimal) weight $w$ are discovered $n_1$, $n_2$, $\ldots$ , $n_m$ times, respectively, we can estimate the corresponding Poisson parameter as 
\[ \lambda_w =\frac{1}{N m}\sum_{i=1}^m n_i. \]
 

 Then, the probability that a codeword $c_0$ of the true minimal weight $ d < w $ be \emph{not} discovered after $N$ steps can be upper bounded as (the inequalities here become equalities in the
limit of small $\lambda_w$) 
\[ P_{\rm fail} < (1-\lambda_w)^N < e^{-N\lambda_w}=\exp\left(-m^{-1}\sum_{i=1}^m
n_i\right)\equiv \exp(-\langle n\rangle). \]
 Thus, the probability to fail is decreasing as an exponent of the parameter $\langle n\rangle$, the \emph{average number of times a minimum-weight codeword has been found.} 

 The hypothesis about all $P(c_i)$ being equal to $\lambda_w$ is testable, e.g., if one considers the distribution of the ratios $x_i=n_i/N$, where $N=\sum_{i=1}^m n_i$ is the total number of codewords found. These quantities sum up to one and are
distributed according to multinomial distribution\cite{Steel-1953}. Further, under our assumption of all $P(c_i)$ being equal, we also expect the outcome probabilities in the multinomial
distribution to be all equal, $\pi_i=1/m$, $1\le i\le m$. 

 This hypothesis can be tested using Pearson's $\chi^2$ test. Namely, in the limit where the total number of observations $N$ diverges, the quantity 
\[ X^2=\sum_{i=1}^m \frac{(n_i-N \pi_i)^2}{ N\pi_i}= N^{-1}\sum_{i=1}^m
\frac{n_i^2}{\pi_i}-N \stackrel{\pi_i=1/m}\to\frac{m}{N}\sum_{i=1}^m n_i^2-N, \]
 is expected to be distributed according to the $\chi^2_{m-1}$ distribution with $m-1$ parameters, see \cite{Chernoff-Lehmann-1954} \cite{Cramer-book-1999}. 

 In practice, we can approximate with the $\chi^2_{m-1}$ distribution as long as the total $N$ be large compared to the number $m$ of the codewords found (i.e., the average $\langle n\rangle$ must be large, which is the same condition as needed for confidence in the
result.) 

 With \texttt{debug[4]} set (binary value 8) in \texttt{DistRandCSS} and \texttt{DistRandStab} \ref{Section_DistanceFunctions}, whenever more than one minimum-weight vector is found, the quantity $X^2$ is computed and output along with the average number of times $\langle n\rangle$ a minimum-weight codeword has been found. However, no attempt is made to
analyze the corresponding value or calculate the likelihood of the null
hypothesis that the codewords be equiprobable. 

 }

 }

   
\chapter{\textcolor{Chapter }{All Functions}}\label{Chapter_AllFunctions}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7C6522597D7E72FE}{}
{
  

 
\section{\textcolor{Chapter }{Functions for computing the distance}}\label{Section_DistanceFunctions}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X826856C47F9890F3}{}
{
  

 
\subsection{\textcolor{Chapter }{Examples}}\label{Chapter_AllFunctions_Section_DistanceFunctions_Subsection_Examples}
\logpage{[ 4, 1, 1 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
  Here are a few simple examples illustrating the use of distance functions. In
all examples, we use \texttt{DistRandCSS} and \texttt{DistRandStab} with \texttt{debug=2} to ensure that row orthogonality in the input matrices is verified. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(5);;|
  !gapprompt@gap>| !gapinput@Hx:=One(F)*[[1,-1,0,0 ],[0,0,1,-1]];;|
  !gapprompt@gap>| !gapinput@Hz:=One(F)*[[1, 1,1,1]];;|
  !gapprompt@gap>| !gapinput@DistRandCSS(Hz,Hx,100,0,2 : field:=F);|
  2
\end{Verbatim}
 Now, if we set the minimum distance \texttt{mindist} parameter too large, the function terminates immediately after a codeword with
such a weight is found; in such a case the result is returned with the
negative sign. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@DistRandCSS(Hz,Hx,100,2,2 : field:=F);|
  -2
\end{Verbatim}
 The function \texttt{DistRandStab} takes only one matrix. This example uses the same CSS code but written into a
single matrix. Notice how the values from the previous example are
intercalated with zeros. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(5);;|
  !gapprompt@gap>| !gapinput@H:=One(F)*[[1,0, -1,0,  0,0,  0,0 ], # original Hx in odd positions|
  !gapprompt@>| !gapinput@           [0,0,  0,0,  1,0, -1,0 ],|
  !gapprompt@>| !gapinput@           [0,1,  0,1,  0,1,  0,1 ]];; # original Hz in even positions|
  !gapprompt@gap>| !gapinput@DistRandStab(H,100,0,2 : field:=F);|
  2
\end{Verbatim}
 }

 

 

\subsection{\textcolor{Chapter }{DistRandCSS}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X83CF58308216037F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DistRandCSS({\mdseries\slshape HX, HZ, num, mindist[, debug]: field := GF(2), maxav := fail})\index{DistRandCSS@\texttt{DistRandCSS}}
\label{DistRandCSS}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
An upper bound on the CSS distance $d_Z$ 



 Computes an upper bound on the distance $d_Z$ of the $q$-ary code with stabilizer generator matrices $H_X$, $H_Z$ whose rows are assumed to be orthogonal (\emph{orthogonality is not verified}). See Section \ref{Section_SimpleVersion} for the description of the algorithm. 

 Details of the input parameters 
\begin{itemize}
\item  \texttt{HX}, \texttt{HZ}: the input matrices with elements in the Galois \texttt{field} $F$ 
\item  \texttt{num}: number of information sets to construct (should be large) 
\item  \texttt{mindist} - the algorithm stops when distance equal or below \texttt{mindist} is found and returns the result with negative sign. Set \texttt{mindist} to 0 if you want the actual distance. 
\item  \texttt{debug}: optional integer argument containing debug bitmap (default: \texttt{0}) 
\begin{itemize}
\item  1 (0s bit set) : print 1st of the vectors found 
\item  2 (1st bit set) : check orthogonality of matrices and of the final vector 
\item  4 (2nd bit set) : show occasional progress update 
\item  8 (3rd bit set) : maintain cw count and estimate the success probability 
\end{itemize}
 
\item  \texttt{field} (Options stack): Galois field, default: $GF(2)$. 
\item  \texttt{maxav} (Options stack): if set, terminate when $\langle n\rangle${\textgreater}\texttt{maxav}, see Section \ref{Subsection_DistRandCSS}. Not set by default. 
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{DistRandStab}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X7894F0027B144AB8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DistRandStab({\mdseries\slshape H, num, mindist[, debug]: field := GF(2), maxav := fail})\index{DistRandStab@\texttt{DistRandStab}}
\label{DistRandStab}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
An upper bound on the code distance $d$ 



 Computes an upper bound on the distance $d$ of the $F$-linear stabilizer code with generator matrix $H$ whose rows are assumed to be symplectic-orthogonal, see Section \ref{Subsection_DistRandStab} (\emph{orthogonality is not verified}). 

 Details of the input parameters: 
\begin{itemize}
\item  \texttt{H}: the input matrix with elements in the Galois \texttt{field} $F$ with $2n$ columns $(a_1,b_1,a_2,b_2,\ldots,a_n,b_n)$. 
\end{itemize}
 The remaining options are identical to those in the function \texttt{DistRandCSS} \ref{DistRandCSS}. 
\begin{itemize}
\item  \texttt{num}: number of information sets to construct (should be large) 
\item  \texttt{mindist} - the algorithm stops when distance equal or smaller than \texttt{mindist} is found - set it to 0 if you want the actual distance 
\item  \texttt{debug}: optional integer argument containing debug bitmap (default: \texttt{0}) 
\begin{itemize}
\item  1 (0s bit set) : print 1st of the vectors found 
\item  2 (1st bit set) : check orthogonality of matrices and of the final vector 
\item  4 (2nd bit set) : show occasional progress update 
\item  8 (3rd bit set) : maintain cw count and estimate the success probability 
\end{itemize}
 
\item  \texttt{field} (Options stack): Galois field, default: $GF(2)$. 
\item  \texttt{maxav} (Options stack): if set, terminate when $\langle n\rangle${\textgreater}\texttt{maxav}, see Section \ref{Subsection_DistRandCSS}. Not set by default. 
\end{itemize}
 }

 }

 
\section{\textcolor{Chapter }{Input/Output Functions}}\label{Section_IOFunctions}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X7E4EA2B38128F66B}{}
{
  

 

\subsection{\textcolor{Chapter }{ReadMTXE}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X86210A658573655F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ReadMTXE({\mdseries\slshape FilePath[, pair]: field := GF(2)})\index{ReadMTXE@\texttt{ReadMTXE}}
\label{ReadMTXE}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list [\texttt{field}, \texttt{pair}, \texttt{Matrix}, \texttt{array{\textunderscore}of{\textunderscore}comment{\textunderscore}strings}] 



 Read matrix from an MTX file, an extended version of Matrix Market eXchange
coordinate format supporting finite Galois fields and two-block matrices $ (A|B) $ with columns $A=(a_1, a_2, \ldots , a_n)$ and $B=(b_1, b_2, \ldots , b_n)$, see Chapter \ref{Chapter_FileFormat}. 

 
\begin{itemize}
\item  \texttt{FilePath} name of existing file storing the matrix 
\item  \texttt{pair} (optional argument): specifies column ordering; must correlate with the
variable \texttt{type} in the file 
\begin{itemize}
\item  \texttt{pair=0} for regular single-block matrices (e.g., CSS) \texttt{type=integer} (if \texttt{pair} not specified, \texttt{pair}=0 is set by default for \texttt{integer}) 
\item  \texttt{pair=1} intercalated columns with \texttt{type=integer} $ (a_1, b_1, a_2, b_2,\ldots) $ 
\item  \texttt{pair=2} grouped columns with \texttt{type=integer} $ (a_1, a_2, \ldots, a_n\; b_1, b_2,\ldots, b_n) $ 
\item  \texttt{pair=3} this is the only option for \texttt{type=complex} with elements specified as "complex" pairs 
\end{itemize}
 
\item  \texttt{field} (Options stack): Galois field, default: $GF(2)$. \emph{Must} match that given in the file (if any). 
\end{itemize}
 \emph{Notice}: with \texttt{pair}=1 and \texttt{pair}=2, the number of columns specified in the file must be even, twice the block
length of the code 

 1st line of file must read: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
   %%MatrixMarket matrix coordinate `type` general 
\end{Verbatim}
 with \texttt{type} being either \texttt{integer} or \texttt{complex} 

 2nd line (optional) may contain: 

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
   % Field: `valid_field_name_in_Gap` 
\end{Verbatim}
 Any additional entries in the second line are silently ignored. By default, $GF(2)$ is assumed; the default can be overriden by the optional \texttt{field} argument. If the field is specified both in the file and by the optional
argument, the corresponding values must match. 

 See Chapter \ref{Chapter_FileFormat} for the details of how the elements of the group are represented depending on
whether the field is a prime field ($ q $ a prime) or an extension field with $ q=p^m $, $p$ prime, and $m>1$. 

 }

 

\subsection{\textcolor{Chapter }{WriteMTXE}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X82F72B6082EEDDF9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WriteMTXE({\mdseries\slshape StrPath, pair, matrix[, comment[, comment]]: field := GF(2)})\index{WriteMTXE@\texttt{WriteMTXE}}
\label{WriteMTXE}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
no output 



 Export a \texttt{matrix} in Extended MatrixMarket format, with options specified by the \texttt{pair} argument. 

 
\begin{itemize}
\item  \texttt{StrPath} - name of the file to be created; 
\item  \texttt{pair}: parameter to control the format details, must match the \texttt{type} of the matrix. 
\begin{itemize}
\item  \texttt{pair=0} for regular matrices (e.g., CSS) with \texttt{type=integer} 
\item  \texttt{pair=1} for intercalated columns $ (a_1, b_1, a_2, b_2, \ldots) $ with \texttt{type=integer} 
\item  \texttt{pair=2} for grouped columns with \texttt{type=integer} \emph{(this is not supported!)} 
\item  \texttt{pair=3} for columns specified in pairs with \texttt{type=complex} 
\end{itemize}
 
\item  Columns of the input \texttt{matrix} must be intercalated unless \texttt{pair=0} 
\item  optional \texttt{comment}: one or more strings (or a single list of strings) to be output after the MTX
header line. 
\end{itemize}
 

 The second line specifying the field will be generated automatically only if
the GAP Option \texttt{field} is present. As an option, the line can also be entered explicitly as the first
line of the comments, e.g., \texttt{"\% Field: GF(256)"} 

 See Chapter \ref{Chapter_FileFormat} for the details of how the elements of the group are represented depending on
whether the field is a prime field ($ q $ a prime) or an extension field with $ q=p^m $, $ m>1 $. 

 }

 }

 
\section{\textcolor{Chapter }{Helper Functions}}\label{Section_HelperFunctions}
\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X7BD4785D8488BAD5}{}
{
  

 
\subsection{\textcolor{Chapter }{Examples}}\label{Chapter_AllFunctions_Section_HelperFunctions_Subsection_Examples}
\logpage{[ 4, 3, 1 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
  
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@QDR_AverageCalc([2,3,4,5]);|
  3.5
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(3);; |
  !gapprompt@gap>| !gapinput@x:=Indeterminate(F,"x");; poly:=One(F)*(1-x);;|
  !gapprompt@gap>| !gapinput@n:=5;;|
  !gapprompt@gap>| !gapinput@mat:=QDR_DoCirc(poly,n,2*n,F);; # make a circulant matrix with 5 rows |
  !gapprompt@gap>| !gapinput@Display(mat);|
   1 2 . . . . . . . .
   . . 1 2 . . . . . .
   . . . . 1 2 . . . .
   . . . . . . 1 2 . .
   . . . . . . . . 1 2
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{QDR{\textunderscore}AverageCalc}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X80975EC07BDC757B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{QDR{\textunderscore}AverageCalc({\mdseries\slshape vector})\index{QDR{\textunderscore}AverageCalc@\texttt{QDR{\textunderscore}AverageCalc}}
\label{QDRuScoreAverageCalc}
}\hfill{\scriptsize (function)}}\\


 Calculate the average of the components of a \texttt{vector} containing numbers }

 

\subsection{\textcolor{Chapter }{QDR{\textunderscore}SymplVecWeight}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X8615F38C79B4684C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{QDR{\textunderscore}SymplVecWeight({\mdseries\slshape vector, field})\index{QDR{\textunderscore}SymplVecWeight@\texttt{QDR{\textunderscore}SymplVecWeight}}
\label{QDRuScoreSymplVecWeight}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
symplectic weight of a vector 



 Calculate the symplectic weight of a \texttt{vector} with an even number of entries from the field \texttt{field}. The elements of the pairs are intercalated: $(a_1, b_1, a_2, b_2,\ldots)$. 

 \emph{Note: the parity of vector \texttt{length} and the format are not verified!!!} }

 

\subsection{\textcolor{Chapter }{QDR{\textunderscore}WeightMat}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X80BB67727F7F99C3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{QDR{\textunderscore}WeightMat({\mdseries\slshape matrix})\index{QDR{\textunderscore}WeightMat@\texttt{QDR{\textunderscore}WeightMat}}
\label{QDRuScoreWeightMat}
}\hfill{\scriptsize (function)}}\\


 count the total number of non-zero entries in a matrix. }

 

\subsection{\textcolor{Chapter }{QDR{\textunderscore}DoProbOut}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X8441E8807AE9C477}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{QDR{\textunderscore}DoProbOut({\mdseries\slshape vector, n, num})\index{QDR{\textunderscore}DoProbOut@\texttt{QDR{\textunderscore}DoProbOut}}
\label{QDRuScoreDoProbOut}
}\hfill{\scriptsize (function)}}\\


 aux function to print out the relevant probabilities given the list \texttt{vector} of multiplicities of the codewords found. Additional parameters are \texttt{n}, the code length, and \texttt{num}, the number of repetitions; these are ignored in the present version of the
program. See \ref{Section_Empirical} for the importance of these parameters. }

 

\subsection{\textcolor{Chapter }{QDR{\textunderscore}MakeH}}
\logpage{[ 4, 3, 6 ]}\nobreak
\hyperdef{L}{X8020FCA787C830FE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{QDR{\textunderscore}MakeH({\mdseries\slshape matrix, field})\index{QDR{\textunderscore}MakeH@\texttt{QDR{\textunderscore}MakeH}}
\label{QDRuScoreMakeH}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{H} (the check matrix constructed) 



 Given a two-block \texttt{matrix} with intercalated columns $ (a_1, b_1, a_2, b_2, \ldots) $, calculate the corresponding check matrix \texttt{H} with columns $ (-b_1, a_1, -b_2, a_2, \ldots) $. 

 The parity of the number of columns is verified. }

 

\subsection{\textcolor{Chapter }{QDR{\textunderscore}DoCirc}}
\logpage{[ 4, 3, 7 ]}\nobreak
\hyperdef{L}{X819DC3247F3F7B4F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{QDR{\textunderscore}DoCirc({\mdseries\slshape poly, m, n, field})\index{QDR{\textunderscore}DoCirc@\texttt{QDR{\textunderscore}DoCirc}}
\label{QDRuScoreDoCirc}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{m} by \texttt{2*n} circulant matrix constructed from the polynomial coefficients 



 Given the polynomial \texttt{poly} $a_0+b_0 x+a_1x^2+b_1x^3 +\ldots$ with coefficients from the field \texttt{F}, constructs the corresponding \texttt{m} by 2\texttt{n} double circulant matrix obtained by \texttt{m} repeated cyclic shifts of the coefficients' vector by $s=2$ positions at a time. }

 }

 }

   
\chapter{\textcolor{Chapter }{Extended MTX (MTXE) File Format}}\label{Chapter_FileFormat}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X7D0187B5831B764D}{}
{
  

 
\section{\textcolor{Chapter }{General information}}\label{Chapter_FileFormat_Section_General_information}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7E294E8678035D23}{}
{
  

 The code supports reading matrices from an MTX file using \texttt{ReadMTXE} and writing new MTX file using \texttt{WriteMTXE} functions. Below a description of the format is given. 

 
\subsection{\textcolor{Chapter }{Representation of field elements via integers}}\label{Chapter_FileFormat_Section_General_information_Subsection_Representation_of_field_elements_via_integers}
\logpage{[ 5, 1, 1 ]}
\hyperdef{L}{X8269F2367856BB1E}{}
{
  

 Every finite field is isomorphic to a Galois field $F=GF(q)$, where $q$ is a power of a prime, $q=p^m$. 

 
\begin{itemize}
\item  When $q=p$ is a prime, $F$ is a prime field, isomorphic to the ring Z$(q)$ of integers modulo $q$. In such a case, elements of the field are stored directly as integers from Z$(p)$, ranging from $0$ to $p-1$. 
\end{itemize}
 

 
\begin{itemize}
\item  When $q=p^m$ with $m > 1$, $F$ is an extension field. Elements of such a field could in principle be
represented as polynomials modulo an irreducible polynomial with coefficients
in the prime field $GF(p)$. In the actual file format, we chose to represent non-zero elements as
integers, specifying the powers of a primitive element, while the zero field
element is represented as $-1$. Notice that, depending on the choice of the primitive element, the elements
of the field may be permuted. However, any such permutation is a field
isomorphism preserving the multiplication table. In particular, orthogonality
between the rows of the matrices is necessarily preserved. 
\end{itemize}
 

 
\begin{itemize}
\item  On input, other integer values are allowed; they are taken modulo $p$ for a prime field, and as the powers of the primitive element for an extension
field. This is often convenient, e.g., with $\pm1$ matrices which obey the orthogonality condition already over integers, and
thus retain orthogonality over Z$(q)$ with any $q$ (what is more relevant here, the same matrix would work with any prime field). 
\end{itemize}
 

 }

 
\subsection{\textcolor{Chapter }{Matrix storage format}}\label{Chapter_FileFormat_Section_General_information_Subsection_Matrix_storage_format}
\logpage{[ 5, 1, 2 ]}
\hyperdef{L}{X86FBB72C7BC3B8D2}{}
{
  

 The generator matrix storage format dependes on 2 parameters: \texttt{pair} and \texttt{type}. 

 
\begin{itemize}
\item  With \texttt{pair=0} the matrix elements are stored in the usual order.. This is the defailt
storage format for stabilizer generator matrices of CSS codes. In this case \texttt{type=integer}, since matrix elements are stored as integers. 
\end{itemize}
 

 
\begin{itemize}
\item  With \texttt{pair=1} the block matrix $(A,B)$ is stored with intercalated columns $(a_1,b_1,\ldots,a_n,b_n)$. In this case \texttt{type=integer}. 
\end{itemize}
 

 
\begin{itemize}
\item  With \texttt{pair=2} the block matrix $(A,B)$ is stored with separated columns $(a_1,\ldots,a_n, b_1,\ldots,b_n)$. In this case \texttt{type=integer}. 
\end{itemize}
 

 
\begin{itemize}
\item  With \texttt{pair=3} the block matrix $(A,B)$ is stored as a complex matrix $A+iB$, with columns $(a_1 + i b_1,\ldots,a_n + i b_n)$. In this case \texttt{type=complex}, since matrix elements are represented as complex integers. 
\end{itemize}
 

 By default, \texttt{pair=0} corresponds to \texttt{type=integer} and \texttt{pair=3} corresponds to \texttt{type=complex}. 

 For efficiency reasons, the function \texttt{DistRandStab} \ref{Section_DistanceFunctions} assumes the generator matrix with intercalated columns. 

 }

 
\subsection{\textcolor{Chapter }{Explicit format of each line}}\label{Chapter_FileFormat_Section_General_information_Subsection_Explicit_format_of_each_line}
\logpage{[ 5, 1, 3 ]}
\hyperdef{L}{X80B886F0796AF0D5}{}
{
  

 The first line must have the following form: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  %%MatrixMarket matrix coordinate `type` general
\end{Verbatim}
 with \texttt{type} either \texttt{integer} or \texttt{complex}. 

 The second line is optional and specifies the field. The field may be left
undefined; by default, it is $GF(2)$, or it can be specified by hand when reading the matrices. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  % Field: GF(q) 
\end{Verbatim}
 

 Next the comment section is specified, with each line starting with the \texttt{\%} symbol: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  % Example of the comment line
\end{Verbatim}
 

 After the comment section there is the line with properties of the matrix: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  rows     columns     (number of non-zero elements)
\end{Verbatim}
 

 Then all non-zero elements are listed according to the \texttt{type}: 

 
\begin{itemize}
\item  \texttt{type=integer}: 
\end{itemize}
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  i     j     element[i,j]
\end{Verbatim}
 

 
\begin{itemize}
\item  \texttt{type=complex}: 
\end{itemize}
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  i     j     a[i,j]     b[i,j]
\end{Verbatim}
 

 Notice that column and row numbers start with 1. 

 }

 }

 
\section{\textcolor{Chapter }{Example MTXE files}}\label{Chapter_FileFormat_Section_Example_MTXE_files}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7F2C657F869D90AD}{}
{
  

 In this section we give two sample MTXE files storing the stabilizer generator
matrix of 5-qubit codes. 

 First, matrix (with one redundant linearly-dependent row) stored with \texttt{type=integer} and \texttt{pair=1} (intercalated columns $[a_1,b_1,a_2,b_2,\ldots]$) is presented. Notice that the number of columns is twice the actual length
of the code. Even though the field is specified explicitly, this matrix would
work with any prime field. 

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  %%MatrixMarket matrix coordinate integer general		
  % Field: GF(7)
  % 5-qubit code generator matrix / normal storage with intercalated cols
  5 10 20
  1 1 1
  1 4 1
  1 6 -1
  1 7 -1
  2 3 1
  2 6 1
  2 8 -1
  2 9 -1
  3 1 -1
  3 5 1
  3 8 1
  3 10 -1
  4 2 -1
  4 3 -1
  4 7 1
  4 10 1
  5 2 1
  5 4 -1
  5 5 -1
  5 9 1
\end{Verbatim}
 

 This same matrix is stored in the file \texttt{matrices/n5k1A.mtx}. This is how the matrix can be read and distance calculated: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@    lis:=ReadMTXE("matrices/n5k1A.mtx" );;|
  !gapprompt@gap>| !gapinput@    Print("field ",lis[1],"\n");|
  field GF(7)
  !gapprompt@gap>| !gapinput@    dist:=DistRandStab(lis[3],100,0 : field:=lis[1]);|
  3
\end{Verbatim}
 

 The same matrix can also be stored with \texttt{type=complex} and \texttt{pair=3} (complex pairs $[a_1+i b_1,a_2+i b_2,\ldots]$). In this format, the number of columns equals the code length. 

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  %%MatrixMarket matrix coordinate complex general
  % works with any prime field
  % 5-qubit code generator matrix / normal storage with intercalated cols
  % [[5,1,3]]_p
  4 5 16
  1 1 1 0
  1 2 0 1
  1 3 0 -1
  1 4 -1 0
  2 2 1 0
  2 3 0 1
  2 4 0 -1
  2 5 -1 0
  3 1 -1 0
  3 3 1 0
  3 4 0 1
  3 5 0 -1
  4 1 0 -1
  4 2 -1 0
  4 4 1 0
  4 5 0 1
\end{Verbatim}
 

 The matrix above is written in the file \texttt{matrices/n5k1.mtx}. To calculate the distance, we need to specify the field [unless we want to
use the default binary field]. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@    lis:=ReadMTXE("matrices/n5k1.mtx" );;|
  !gapprompt@gap>| !gapinput@    Print("field ",lis[1],"\n");|
  field GF(2)
  !gapprompt@gap>| !gapinput@    dist:=DistRandStab(lis[3],100,0,2 : field:=lis[1]);|
  3
  !gapprompt@gap>| !gapinput@    q:=17;;|
  !gapprompt@gap>| !gapinput@    lis:=ReadMTXE("matrices/n5k1.mtx" : field:= GF(q));;|
  !gapprompt@gap>| !gapinput@    Print("field ",lis[1],"\n");|
  field GF(17)
  !gapprompt@gap>| !gapinput@    dist:=DistRandStab(lis[3],100,0,2 : field:=lis[1]);|
  3
\end{Verbatim}
 }

 

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{QDistRnd.bib}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\immediate\write\pagenrlog{["Ind", 0, 0], \arabic{page},}
\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
